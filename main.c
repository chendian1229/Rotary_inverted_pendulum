#include <msp430.h> 
#include <stdio.h>
//#include "TA_PWM.h"
#include "UART_Init.h"
#include "ADC_Init.h"

/*************************************************************
 *
 *						子函数声明
 *
 *************************************************************/
void P23_Onclick();							//P23中断处理函数
void P24_Onclick();							//P24中断处理函数
void P2_IODect();							//P2口中断判断函数，共用中断向量表
void Write_String(char *string);			//字符串转换函数
void GPIO_Init();							//GPIO初始化函数
void WDT_Ontime();							//看门狗中断函数5Ms触发一次
int Balance_PID(int Encoder,int Target);	//保持倒立摆平衡的PID
int PWM_Judgement( int PWM);				//PWM正负值判断函数
void Timer_A0_1_init() ;					//定时器A0输出PWM波函数
void End();									//串口屏幕结束指令函数
/**************************************************************
 *
 * 					程序传递参数，全局变量
 *
 **************************************************************/

signed int Position=0;							//编码器返回位置参数
float BP=6.4,BI=0,BD=3.5;						//定义平衡PID参数
float SP=0,SI=0,SD=0;						//定义位置PID参数
char str1[20]={};							//定义一个空字符串，用于转换字符
/***************************************************************
 * 名       称：主函数
 * 功       能：程序入口，初始化函数
 **************************************************************/
void main(void)
{
	WDTCTL = WDT_MDLY_8;					  //定时周期为0.5ms
    IE1 |=WDTIE;							  //使能WDT中断


	char str2[20]={};							//定义一个空字符串，用于转换字符
	//unsigned int Bright=0;

//-------设置系统时钟MSCLK-----------
	BCSCTL1 = CALBC1_1MHZ;                    // Set DCO为1MHZ
	DCOCTL = CALDCO_1MHZ;
//-------初始化PWM，时钟源SMCLK，不分频，增计数模式，普通PWM
//    TA0_PWM_Init('S',1,'F',0);
//    TA0_PWM_SetPeriod(10000);



	Timer_A0_1_init();
    GPIO_Init();							 //初始化GPIO口
    UART_Init();							 //初始化串口UART
    ADC_Init();								 //初始化ADC,输入引脚为P1.5

    _enable_interrupts();					 //使能中断

	  while(1)
	  {


//		  Speed=Speed-LSpeed;
//		  sprintf(str1,"%d  ",Speed);
//		  Write_String(str1);
//		  LSpeed=Speed;

		  sprintf(str2,"t0.txt=\"%d\"",AD);
		  Write_String(str2);
		  End();


		 //_delay_cycles(100000);

	  }

}
/******************************************************************************************************
 * 名       称：串口屏幕结束指令函数
 * 功       能：输出三个0xff，结束输入
 ******************************************************************************************************/
void End()
{
	UCA0TXBUF=0xff;
	__delay_cycles(10000);
	UCA0TXBUF=0xff;
	__delay_cycles(10000);
	UCA0TXBUF=0xff;
	__delay_cycles(10000);
}

/******************************************************************************************************
 * 名       称：PWM正负值判断函数
 * 功       能：根据PWM正负值判断电机正反转，输出正确PWM值给电机
 ******************************************************************************************************/
int PWM_Judgement( int PWM)
{
	if(PWM>=0)
	{
		P1OUT |=BIT4;
		P1OUT &=~BIT3;
	}
	else
	{
		P1OUT |=BIT3;
		P1OUT &=~BIT4;
		PWM=-PWM;
	}
	PWM=PWM/8;
	return PWM;
}
void Timer_A0_1_init()  			//TA0.1输出PWM
{

	P1SEL |=  BIT6;					//P1.6输出PWM
	P1DIR |=  BIT6;


	TA0CCR0 = 10000;						//设置周期（频率）
	TA0CCR1 = 10;							//占空比CCR1/CCR0

	TA0CCTL1 = OUTMOD_7;				//输出模式为复位/置位
	TA0CTL |= TASSEL_2 + MC_1;		//选择时钟,增计数
}
/******************************************************************************************************
 * 名       称：保持倒立摆平衡计算函数
 * 功       能：根据PID公式求得PWM相应参数，保持倒立摆平衡
 ******************************************************************************************************/
int Balance_PID(int Encoder,int Target)
{
	static int Bias,Pwm,Integral_bias,Last_Bias;
	Bias=Encoder-Target;			//计算偏差
	Integral_bias+=Bias;			//求出偏差的积分
	Pwm=BP*Bias+BI*Integral_bias+BD*(Bias-Last_Bias);
	Last_Bias=Bias;					//保存上一次偏差
	return Pwm;						//输出计算值
}
/******************************************************************************************************
 * 名       称：定时器(看门狗)中断处理函数1
 * 功       能：
 ******************************************************************************************************/
void WDT_Ontime()
{
	ADC10CTL0 |= ENC + ADC10SC;    			      // AD开启，单通道单次采样，循环实现单通道多次采样
	unsigned int i=0,j=808;						//设置倒立摆平衡位置参数
	int PWM_Judge,Bright;						//设置PID 返回参数赋值变量 ;
	i=AD;									//将AD转换值赋给i变量
	PWM_Judge=Balance_PID(i,j);				//调用PID函数
	Bright=PWM_Judgement(PWM_Judge);		//调用PWM正负值判断
//	sprintf(str1,"%d\n",Bright);
//	Write_String(str1);
	if((AD<910)&&(AD>680))	TA0CCR1=Bright;
	else					TA0CCR1=0;
	//TA0CCR1=Bright;

}

/******************************************************************************************************
 * 名       称：GPIO_Init()
 * 功       能：设定各个IO口
 ******************************************************************************************************/
void GPIO_Init()
{
	//TA0_PWM_Init()自动设置P1.6为PWM输出
	//ADC_Init()	自动设置P1.5为ADC输入引脚
	//UART_Init()	自动设置P1.1为RXD，P1.2为TXD

	P1DIR |=BIT0;						//设定P1.0为输出
	P1OUT &=~BIT0;						//且P1.0设为0

	//-----配置P1.3，P1.4为驱动电路IO
	P1DIR |=BIT3+BIT4;
	P1OUT |=BIT4;
	P1OUT &=~BIT3;

	//-----配置P2.3,P2.4中断参数----- 编码器A(BIT3),B(BIT4)相
	P2DIR &= ~BIT3;                   	// P2.3设为输入
	P2DIR &= ~BIT4;						// P2.4设为输入
	P2IES |= BIT3+BIT4;                 // P2.3,P2.4设为下降沿中断
	P2IE  |= BIT3+BIT4 ;                // 允许P2.3中断

}

/**************************************************************
 *
 * 功       能：字符串发送LCD函数
 *
 **************************************************************/
void Write_String(char *string)
{
	int i;
	for(i=0;string[i]!='\0';i++)
	{
		UCA0TXBUF=string[i];
		_delay_cycles(5000);
	}
}
/******************************************************************************************************
 * 名       称：P2_IODect()
 * 功       能：判断具体引发中断的IO，并调用相应IO的中断事件处理函数
 * 说       明：该函数兼容所有8个IO的检测，请根据实际输入IO激活“检测代码”。
 *
 ******************************************************************************************************/
void P2_IODect()
{
	unsigned int Push_Key=0;
	//-----排除输出IO的干扰后，锁定唯一被触发的中断标志位-----
	Push_Key=P2IFG&(~P1DIR);

	if((P2IN&Push_Key)==0) 	                	//如果该次按键确实有效
   {
	 //----判断具体哪个IO被按下，调用该IO的事件处理函数-----
	  switch(Push_Key)
	  {
	   case BIT3: 	P23_Onclick();		break;
	   case BIT4:	P24_Onclick();		break;
	   default:							break;		//任何情况下均加上default
	  }
   }
}
/******************************************************************************************************
 * 名    称：P23_Onclick()
 * 功    能：P2.3的中断事件处理函数，即当P2.3键被按下后，下一步干什么
 * 说    明：判断P23触发中断以后，P24是否为低电平，低电平则为正向转速
 ******************************************************************************************************/
void P23_Onclick()
{


	if((P2IN&BIT4)==0)		Position++;
	else					Position--;

}
/******************************************************************************************************
 * 名    称：P24_Onclick()
 * 功    能：P2.3的中断事件处理函数，即当P2.3键被按下后，下一步干什么
 * 说    明：判断P24触发中断以后，P23是否为高电平，高电平则为反向转速
 ******************************************************************************************************/
void P24_Onclick()
{
	if((P2IN&BIT3)==0)		Position--;
	else					Position++;

}

/******************************************************************************************************
 * 名       称：PORT2_ISR()
 * 功       能：响应P2口的外部中断服务
 * 说       明：P2.0~P2.8共用了PORT2中断，所以在PORT2_ISR()中必须查询标志位P2IFG才能知道
 * 					 具体是哪个IO引发了外部中断。P2IFG必须手动清除，否则将持续引发PORT2中断。
 ******************************************************************************************************/
#pragma vector = PORT2_VECTOR
__interrupt void PORT2_ISR(void)
{
	//-----启用Port2事件检测函数-----
	P2_IODect();								//检测通过，则会调用事件处理函数
   	P2IFG=0;                            		//退出中断前必须手动清除IO口中断标志
}

/******************************************************************************************************
 * 名       称：看门狗中断服务函数
 * 说       明：设定10Ms进入一次中断
 * 功       能：暂无
 ******************************************************************************************************/
#pragma vector =WDT_VECTOR
__interrupt void WDT_ISR (void)
{
//-----------8ms产生一次中断

		WDT_Ontime();							//看门狗中断处理函数


}
